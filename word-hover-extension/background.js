// This will handle background tasks for the extension
// Load config.js which contains API keys from .env (generated by build.js)
importScripts('config.js');

// Validate that config was loaded
if (typeof CONFIG === 'undefined' || !CONFIG.GEMINI_API_KEY) {
  console.error('‚ùå Error: CONFIG.GEMINI_API_KEY not found. Please run "npm run build" to generate config.js from .env');
}

chrome.runtime.onInstalled.addListener(() => {
  console.log('Word Hover Translator extension installed.');
  
  // Test API connectivity on installation
  setTimeout(() => {
    testAPIConnectivity();
  }, 2000);
});

async function testAPIConnectivity() {
  console.log('üß™ Testing API connectivity...');
  
  try {
    const apiKey = CONFIG.GEMINI_API_KEY;
    if (!apiKey) {
      console.error('‚ùå API key not configured. Please run "npm run build" to generate config.js');
      return;
    }
    const endpoint = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + apiKey;
    
    const testBody = {
      contents: [{ 
        parts: [{ text: 'Test message. Respond with: {"test": "success"}' }] 
      }],
      generationConfig: {
        temperature: 0.1,
        maxOutputTokens: 50
      }
    };
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(testBody)
    });
    
    if (response.ok) {
      const data = await response.json();
      console.log('‚úÖ API connectivity test PASSED');
      console.log('Test response:', data);
    } else {
      const errorText = await response.text();
      console.error('‚ùå API connectivity test FAILED');
      console.error('Status:', response.status, response.statusText);
      console.error('Error:', errorText);
      
      // Specific error analysis
      if (response.status === 429) {
        console.error('üö´ RATE LIMIT: API quota exceeded or too many requests');
      } else if (response.status === 401) {
        console.error('üîë AUTH ERROR: Invalid API key');
      } else if (response.status === 403) {
        console.error('üö´ ACCESS DENIED: API key lacks permission');
      } else if (response.status === 404) {
        console.error('‚ùì NOT FOUND: Model may not exist or endpoint changed');
      }
    }
    
  } catch (error) {
    console.error('‚ùå API connectivity test FAILED with exception:');
    console.error(error);
    
    if (error.message.includes('Failed to fetch')) {
      console.error('üåê NETWORK ERROR: Check internet connection or firewall');
    }
  }
}

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  console.log('Background received message:', message);
  if (message.action === 'translate') {
    // Handle async operation
    handleTranslation(message, sendResponse);
    return true; // Keep the message channel open for async response
  }
});

let isRequestInProgress = false; // A "gate" to prevent concurrent requests
let currentAbortController = null; // To cancel in-flight requests

async function handleTranslation(message, sendResponse) {
  // If a request is already happening, cancel it and start a new one
  if (isRequestInProgress && currentAbortController) {
    console.log('Cancelling previous request and starting new one.');
    currentAbortController.abort();
  }
  
  // Create new abort controller for this request
  currentAbortController = new AbortController();
  const signal = currentAbortController.signal;
  
  // Close the gate
  isRequestInProgress = true;

  // Declare apiKey and endpoint outside try block so they're accessible in catch block
  let apiKey;
  let endpoint;

  try {
    // Get API key from config (loaded from .env via build.js)
    apiKey = CONFIG.GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error('API key not configured. Please run "npm run build" to generate config.js from .env');
    }
    endpoint = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + apiKey;
    
    // New, clearer prompt with valid JSON examples to ensure reliable responses.
    const prompt = `Analyze the following text: "${message.word}".
Translate it to ${message.targetLanguage}.
You MUST respond with ONLY a valid, single-line JSON object with two keys: "translation" and "hiragana".

- "translation": This key's value must be the translated text.
- "hiragana": If the original text contains Japanese Kanji, this key's value must be the complete Hiragana reading. If there is no Kanji, the value must be an empty string.

Correct Example 1:
Original Text: "Êó•Êú¨Ë™û"
Response: {"translation": "Japanese", "hiragana": "„Å´„Åª„Çì„Åî"}

Correct Example 2:
Original Text: "„Åì„Çì„Å´„Å°„ÅØ"
Response: {"translation": "Hello", "hiragana": ""}

Do not add any other text, explanations, or markdown formatting outside of the JSON object.`;
    
    const body = {
      contents: [{ 
        parts: [{ text: prompt }] 
      }],
      generationConfig: {
        temperature: 0.1,
        maxOutputTokens: 500
      }
    };

    console.log('Making API request to Gemini...');
    console.log('Request URL:', endpoint);
    console.log('Request body:', JSON.stringify(body, null, 2));
    
    // Add timeout to prevent hanging indefinitely
    const timeoutId = setTimeout(() => {
      if (currentAbortController) {
        currentAbortController.abort();
      }
    }, 30000); // 30 second timeout
    
    let response;
    try {
      response = await fetch(endpoint, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
        signal: signal // Add abort signal
      });
      clearTimeout(timeoutId);
    } catch (fetchError) {
      clearTimeout(timeoutId);
      if (fetchError.name === 'AbortError') {
        throw new Error('Request timeout: The API took too long to respond (30s limit)');
      }
      throw fetchError;
    }
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('API Error Response:', errorText);
      throw new Error(`API error: ${response.status} ${response.statusText} - ${errorText}`);
    }
    
    const data = await response.json();
    console.log('Gemini API response:', data);
    
    // The response from Gemini is expected to be a string of JSON. We need to parse it.
    const responseText = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
    
    // Check if responseText exists
    if (!responseText) {
      throw new Error('API returned empty response. Response structure: ' + JSON.stringify(data));
    }
    
    let parsedResponse = {};
    try {
        // Clean the response to remove any markdown formatting before parsing.
        const cleanedText = responseText.replace(/^```json\s*/, '').replace(/```$/, '').trim();
        parsedResponse = JSON.parse(cleanedText);
        
        // Validate that we got the expected structure
        if (!parsedResponse.translation) {
          throw new Error('Response missing translation field');
        }
    } catch (e) {
        // If parsing fails, it's likely the model didn't return valid JSON.
        console.error("Failed to parse JSON response from Gemini:", responseText);
        console.error("Parse error:", e);
        // Fallback: treat the entire response as the translation
        parsedResponse = { 
            translation: responseText || 'No translation available', 
            hiragana: '' 
        };
    }

    const { translation, hiragana } = parsedResponse;
    
    console.log('Sending response:', { translation, hiragana });
    
    // Ensure we always send a response, even if something goes wrong
    if (typeof sendResponse === 'function') {
      sendResponse({ translation, hiragana });
    } else {
      console.error('sendResponse is not a function! This should not happen.');
    }
    
  } catch (err) {
    console.error('Translation error:', err);
    
    // Detailed error analysis for debugging
    let errorMessage = 'Translation failed';
    let debugInfo = '';
    
    if (err.message.includes('API error: 429')) {
      errorMessage = 'API Rate Limit Exceeded';
      debugInfo = 'The API has reached its quota or rate limit. Try again later.';
    } else if (err.message.includes('API error: 401')) {
      errorMessage = 'API Authentication Failed';
      debugInfo = 'Invalid API key or authentication issue.';
    } else if (err.message.includes('API error: 403')) {
      errorMessage = 'API Access Forbidden';
      debugInfo = 'API key may not have permission for this service.';
    } else if (err.message.includes('API error: 404')) {
      errorMessage = 'API Model Not Found';
      debugInfo = 'The Gemini model may have been changed or deprecated.';
    } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
      errorMessage = 'Network Connection Failed';
      debugInfo = 'Check internet connection or firewall settings.';
    } else if (err.message.includes('Failed to parse JSON')) {
      errorMessage = 'API Response Format Error';
      debugInfo = 'The API returned unexpected response format.';
    } else {
      debugInfo = err.message;
    }
    
    console.error('üîç DEBUG INFO:');
    console.error('Error Type:', errorMessage);
    console.error('Details:', debugInfo);
    console.error('Full Error:', err);
    // Only log apiKey and endpoint if they were successfully initialized
    if (apiKey) {
      console.error('API Key (first 10 chars):', apiKey.substring(0, 10) + '...');
    }
    if (endpoint) {
      console.error('Endpoint:', endpoint);
    }
    
    // Send detailed error back to content script
    if (typeof sendResponse === 'function') {
      sendResponse({ 
        translation: `${errorMessage}: ${debugInfo}`, 
        hiragana: '',
        error: true,
        errorType: errorMessage,
        debugInfo: debugInfo
      });
    } else {
      console.error('sendResponse is not a function in error handler!');
    }
  } finally {
    // IMPORTANT: Open the gate again, whether the request succeeded or failed.
    isRequestInProgress = false;
    currentAbortController = null;
  }
}
